{"name": "test_RunThroughInvalidInputs", "status": "broken", "statusDetails": {"message": "Exception: (<class 'Exception'>, Exception('(<class \\'selenium.common.exceptions.WebDriverException\\'>, WebDriverException(\"\\'geckodriver.exe\\' executable needs to be in PATH. \"), <traceback object at 0x000001F1B780F440>)'), <traceback object at 0x000001F1B780F900>)", "trace": "self = <selenium.webdriver.firefox.service.Service object at 0x000001F1B77EF220>\n\n    def start(self):\n        \"\"\"\n        Starts the Service.\n    \n        :Exceptions:\n         - WebDriverException : Raised either when it can't start the service\n           or when it can't connect to the service\n        \"\"\"\n        try:\n            cmd = [self.path]\n            cmd.extend(self.command_line_args())\n>           self.process = subprocess.Popen(cmd, env=self.env,\n                                            close_fds=platform.system() != 'Windows',\n                                            stdout=self.log_file,\n                                            stderr=self.log_file,\n                                            stdin=PIPE)\n\n..\\dnbassignment\\venv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Popen: returncode: None args: ['C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssig...>\nargs = ['C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssignment Pytest\\\\Utils\\\\WebdriverFactory.py\\\\Driver\\\\geckodriver.exe', '--port', '54039'], bufsize = -1\nexecutable = None, stdin = -1, stdout = <_io.TextIOWrapper name='geckodriver.log' mode='a+' encoding='cp1252'>\nstderr = <_io.TextIOWrapper name='geckodriver.log' mode='a+' encoding='cp1252'>, preexec_fn = None, close_fds = False, shell = False, cwd = None\nenv = environ({'__INTELLIJ_COMMAND_HISTFILE__': 'C:\\\\Users\\\\Dpkpc\\\\AppData\\\\Local\\\\JetBrains\\\\PyCharm2021.1\\\\terminal\\\\histo...7f35f49', 'PYTEST_CURRENT_TEST': 'Tests/test_InvalidLogin.py::Test_InvalidLogin::test_RunThroughInvalidInputs (call)'})\nuniversal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()\n\n    def __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=None,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=(), *, user=None, group=None, extra_groups=None,\n                 encoding=None, errors=None, text=None, umask=-1):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()\n        # Held while anything is calling waitpid before returncode has been\n        # updated to prevent clobbering returncode if wait() or poll() are\n        # called from multiple threads at once.  After acquiring the lock,\n        # code must re-check self.returncode to see if another thread just\n        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n    \n        self._input = None\n        self._communication_started = False\n        if bufsize is None:\n            bufsize = -1  # Restore default\n        if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize must be an integer\")\n    \n        if _mswindows:\n            if preexec_fn is not None:\n                raise ValueError(\"preexec_fn is not supported on Windows \"\n                                 \"platforms\")\n        else:\n            # POSIX\n            if pass_fds and not close_fds:\n                warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n                close_fds = True\n            if startupinfo is not None:\n                raise ValueError(\"startupinfo is only supported on Windows \"\n                                 \"platforms\")\n            if creationflags != 0:\n                raise ValueError(\"creationflags is only supported on Windows \"\n                                 \"platforms\")\n    \n        self.args = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr = None\n        self.pid = None\n        self.returncode = None\n        self.encoding = encoding\n        self.errors = errors\n    \n        # Validate the combinations of text and universal_newlines\n        if (text is not None and universal_newlines is not None\n            and bool(universal_newlines) != bool(text)):\n            raise SubprocessError('Cannot disambiguate when both text '\n                                  'and universal_newlines are supplied but '\n                                  'different. Pass one or the other.')\n    \n        # Input and output objects. The general principle is like\n        # this:\n        #\n        # Parent                   Child\n        # ------                   -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n        #\n        # On POSIX, the child objects are file descriptors.  On\n        # Windows, these are Windows file handles.  The parent objects\n        # are file descriptors on both platforms.  The parent objects\n        # are -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n    \n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n    \n        # We wrap OS handles *before* launching the child, otherwise a\n        # quickly terminating child could make our fds unwrappable\n        # (see #8458).\n    \n        if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(), 0)\n    \n        self.text_mode = encoding or errors or text or universal_newlines\n    \n        # How long to resume waiting on a child after the first ^C.\n        # There is no right value for this.  The purpose is to be polite\n        # yet remain good for interactive users trying to exit a tool.\n        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n    \n        self._closed_child_pipe_fds = False\n    \n        if self.text_mode:\n            if bufsize == 1:\n                line_buffering = True\n                # Use the default buffer size for the underlying binary streams\n                # since they don't support line buffering.\n                bufsize = -1\n            else:\n                line_buffering = False\n    \n        gid = None\n        if group is not None:\n            if not hasattr(os, 'setregid'):\n                raise ValueError(\"The 'group' parameter is not supported on the \"\n                                 \"current platform\")\n    \n            elif isinstance(group, str):\n                if grp is None:\n                    raise ValueError(\"The group parameter cannot be a string \"\n                                     \"on systems without the grp module\")\n    \n                gid = grp.getgrnam(group).gr_gid\n            elif isinstance(group, int):\n                gid = group\n            else:\n                raise TypeError(\"Group must be a string or an integer, not {}\"\n                                .format(type(group)))\n    \n            if gid < 0:\n                raise ValueError(f\"Group ID cannot be negative, got {gid}\")\n    \n        gids = None\n        if extra_groups is not None:\n            if not hasattr(os, 'setgroups'):\n                raise ValueError(\"The 'extra_groups' parameter is not \"\n                                 \"supported on the current platform\")\n    \n            elif isinstance(extra_groups, str):\n                raise ValueError(\"Groups must be a list, not a string\")\n    \n            gids = []\n            for extra_group in extra_groups:\n                if isinstance(extra_group, str):\n                    if grp is None:\n                        raise ValueError(\"Items in extra_groups cannot be \"\n                                         \"strings on systems without the \"\n                                         \"grp module\")\n    \n                    gids.append(grp.getgrnam(extra_group).gr_gid)\n                elif isinstance(extra_group, int):\n                    gids.append(extra_group)\n                else:\n                    raise TypeError(\"Items in extra_groups must be a string \"\n                                    \"or integer, not {}\"\n                                    .format(type(extra_group)))\n    \n            # make sure that the gids are all positive here so we can do less\n            # checking in the C code\n            for gid_check in gids:\n                if gid_check < 0:\n                    raise ValueError(f\"Group ID cannot be negative, got {gid_check}\")\n    \n        uid = None\n        if user is not None:\n            if not hasattr(os, 'setreuid'):\n                raise ValueError(\"The 'user' parameter is not supported on \"\n                                 \"the current platform\")\n    \n            elif isinstance(user, str):\n                if pwd is None:\n                    raise ValueError(\"The user parameter cannot be a string \"\n                                     \"on systems without the pwd module\")\n    \n                uid = pwd.getpwnam(user).pw_uid\n            elif isinstance(user, int):\n                uid = user\n            else:\n                raise TypeError(\"User must be a string or an integer\")\n    \n            if uid < 0:\n                raise ValueError(f\"User ID cannot be negative, got {uid}\")\n    \n        try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite, 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,\n                            line_buffering=line_buffering,\n                            encoding=encoding, errors=errors)\n            if c2pread != -1:\n                self.stdout = io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stdout = io.TextIOWrapper(self.stdout,\n                            encoding=encoding, errors=errors)\n            if errread != -1:\n                self.stderr = io.open(errread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n                            encoding=encoding, errors=errors)\n    \n>           self._execute_child(args, executable, preexec_fn, close_fds,\n                                pass_fds, cwd, env,\n                                startupinfo, creationflags, shell,\n                                p2cread, p2cwrite,\n                                c2pread, c2pwrite,\n                                errread, errwrite,\n                                restore_signals,\n                                gid, gids, uid, umask,\n                                start_new_session)\n\nC:\\Python39\\lib\\subprocess.py:951: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Popen: returncode: None args: ['C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssig...>\nargs = '\"C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssignment Pytest\\\\Utils\\\\WebdriverFactory.py\\\\Driver\\\\geckodriver.exe\" --port 54039', executable = None\npreexec_fn = None, close_fds = False, pass_fds = (), cwd = None\nenv = environ({'__INTELLIJ_COMMAND_HISTFILE__': 'C:\\\\Users\\\\Dpkpc\\\\AppData\\\\Local\\\\JetBrains\\\\PyCharm2021.1\\\\terminal\\\\histo...7f35f49', 'PYTEST_CURRENT_TEST': 'Tests/test_InvalidLogin.py::Test_InvalidLogin::test_RunThroughInvalidInputs (call)'})\nstartupinfo = <subprocess.STARTUPINFO object at 0x000001F1B77EF460>, creationflags = 0, shell = False, p2cread = Handle(612), p2cwrite = 15\nc2pread = -1, c2pwrite = Handle(556), errread = -1, errwrite = Handle(592), unused_restore_signals = True, unused_gid = None, unused_gids = None\nunused_uid = None, unused_umask = -1, unused_start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       unused_restore_signals,\n                       unused_gid, unused_gids, unused_uid,\n                       unused_umask,\n                       unused_start_new_session):\n        \"\"\"Execute program (MS Windows version)\"\"\"\n    \n        assert not pass_fds, \"pass_fds not supported on Windows.\"\n    \n        if isinstance(args, str):\n            pass\n        elif isinstance(args, bytes):\n            if shell:\n                raise TypeError('bytes args is not allowed on Windows')\n            args = list2cmdline([args])\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = list2cmdline([args])\n        else:\n            args = list2cmdline(args)\n    \n        if executable is not None:\n            executable = os.fsdecode(executable)\n    \n        # Process startup details\n        if startupinfo is None:\n            startupinfo = STARTUPINFO()\n        else:\n            # bpo-34044: Copy STARTUPINFO since it is modified above,\n            # so the caller can reuse it multiple times.\n            startupinfo = startupinfo.copy()\n    \n        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n        if use_std_handles:\n            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n            startupinfo.hStdInput = p2cread\n            startupinfo.hStdOutput = c2pwrite\n            startupinfo.hStdError = errwrite\n    \n        attribute_list = startupinfo.lpAttributeList\n        have_handle_list = bool(attribute_list and\n                                \"handle_list\" in attribute_list and\n                                attribute_list[\"handle_list\"])\n    \n        # If we were given an handle_list or need to create one\n        if have_handle_list or (use_std_handles and close_fds):\n            if attribute_list is None:\n                attribute_list = startupinfo.lpAttributeList = {}\n            handle_list = attribute_list[\"handle_list\"] = \\\n                list(attribute_list.get(\"handle_list\", []))\n    \n            if use_std_handles:\n                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n    \n            handle_list[:] = self._filter_handle_list(handle_list)\n    \n            if handle_list:\n                if not close_fds:\n                    warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                  \"overriding close_fds\", RuntimeWarning)\n    \n                # When using the handle_list we always request to inherit\n                # handles but the only handles that will be inherited are\n                # the ones in the handle_list\n                close_fds = False\n    \n        if shell:\n            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n            startupinfo.wShowWindow = _winapi.SW_HIDE\n            comspec = os.environ.get(\"COMSPEC\", \"cmd.exe\")\n            args = '{} /c \"{}\"'.format (comspec, args)\n    \n        if cwd is not None:\n            cwd = os.fsdecode(cwd)\n    \n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n    \n        # Start the process\n        try:\n>           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                     # no special security\n                                     None, None,\n                                     int(not close_fds),\n                                     creationflags,\n                                     env,\n                                     cwd,\n                                     startupinfo)\nE                                    FileNotFoundError: [WinError 2] The system cannot find the file specified\n\nC:\\Python39\\lib\\subprocess.py:1420: FileNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <Utils.WebdriverFactory.WebdriverFactory object at 0x000001F1B77EF910>, browser = 'firefox'\n\n    def get_driver(self, browser):\n        try:\n            print(browser)\n            if browser.lower() == \"firefox\":\n                #driver = webdriver.Firefox(executable_path=\"C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssignment Pytest\\\\Driver\\\\geckodriver.exe\"))\n>               driver = webdriver.Firefox(\n\nUtils\\WebdriverFactory.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <[AttributeError(\"'WebDriver' object has no attribute 'session_id'\") raised in repr()] WebDriver object at 0x1f1b77efbe0>, firefox_profile = None\nfirefox_binary = None, timeout = 30, capabilities = {'acceptInsecureCerts': True, 'browserName': 'firefox'}, proxy = None\nexecutable_path = 'C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssignment Pytest\\\\Utils\\\\WebdriverFactory.py\\\\Driver\\\\geckodriver.exe'\noptions = <selenium.webdriver.firefox.options.Options object at 0x000001F1B77EF3D0>, service_log_path = 'geckodriver.log', firefox_options = None\nservice_args = None, desired_capabilities = None, log_path = None, keep_alive = True\n\n    def __init__(self, firefox_profile=None, firefox_binary=None,\n                 timeout=30, capabilities=None, proxy=None,\n                 executable_path=\"geckodriver\", options=None,\n                 service_log_path=\"geckodriver.log\", firefox_options=None,\n                 service_args=None, desired_capabilities=None, log_path=None,\n                 keep_alive=True):\n        \"\"\"Starts a new local session of Firefox.\n    \n        Based on the combination and specificity of the various keyword\n        arguments, a capabilities dictionary will be constructed that\n        is passed to the remote end.\n    \n        The keyword arguments given to this constructor are helpers to\n        more easily allow Firefox WebDriver sessions to be customised\n        with different options.  They are mapped on to a capabilities\n        dictionary that is passed on to the remote end.\n    \n        As some of the options, such as `firefox_profile` and\n        `options.profile` are mutually exclusive, precedence is\n        given from how specific the setting is.  `capabilities` is the\n        least specific keyword argument, followed by `options`,\n        followed by `firefox_binary` and `firefox_profile`.\n    \n        In practice this means that if `firefox_profile` and\n        `options.profile` are both set, the selected profile\n        instance will always come from the most specific variable.\n        In this case that would be `firefox_profile`.  This will result in\n        `options.profile` to be ignored because it is considered\n        a less specific setting than the top-level `firefox_profile`\n        keyword argument.  Similarily, if you had specified a\n        `capabilities[\"moz:firefoxOptions\"][\"profile\"]` Base64 string,\n        this would rank below `options.profile`.\n    \n        :param firefox_profile: Instance of ``FirefoxProfile`` object\n            or a string.  If undefined, a fresh profile will be created\n            in a temporary location on the system.\n        :param firefox_binary: Instance of ``FirefoxBinary`` or full\n            path to the Firefox binary.  If undefined, the system default\n            Firefox installation will  be used.\n        :param timeout: Time to wait for Firefox to launch when using\n            the extension connection.\n        :param capabilities: Dictionary of desired capabilities.\n        :param proxy: The proxy settings to us when communicating with\n            Firefox via the extension connection.\n        :param executable_path: Full path to override which geckodriver\n            binary to use for Firefox 47.0.1 and greater, which\n            defaults to picking up the binary from the system path.\n        :param options: Instance of ``options.Options``.\n        :param service_log_path: Where to log information from the driver.\n        :param firefox_options: Deprecated argument for options\n        :param service_args: List of args to pass to the driver service\n        :param desired_capabilities: alias of capabilities. In future\n            versions of this library, this will replace 'capabilities'.\n            This will make the signature consistent with RemoteWebDriver.\n        :param log_path: Deprecated argument for service_log_path\n        :param keep_alive: Whether to configure remote_connection.RemoteConnection to use\n             HTTP keep-alive.\n        \"\"\"\n        if log_path:\n            warnings.warn('use service_log_path instead of log_path',\n                          DeprecationWarning, stacklevel=2)\n            service_log_path = log_path\n        if firefox_options:\n            warnings.warn('use options instead of firefox_options',\n                          DeprecationWarning, stacklevel=2)\n            options = firefox_options\n        self.binary = None\n        self.profile = None\n        self.service = None\n    \n        # If desired capabilities is set, alias it to capabilities.\n        # If both are set ignore desired capabilities.\n        if capabilities is None and desired_capabilities:\n            capabilities = desired_capabilities\n    \n        if capabilities is None:\n            capabilities = DesiredCapabilities.FIREFOX.copy()\n        if options is None:\n            options = Options()\n    \n        capabilities = dict(capabilities)\n    \n        if capabilities.get(\"binary\"):\n            self.binary = capabilities[\"binary\"]\n    \n        # options overrides capabilities\n        if options is not None:\n            if options.binary is not None:\n                self.binary = options.binary\n            if options.profile is not None:\n                self.profile = options.profile\n    \n        # firefox_binary and firefox_profile\n        # override options\n        if firefox_binary is not None:\n            if isinstance(firefox_binary, basestring):\n                firefox_binary = FirefoxBinary(firefox_binary)\n            self.binary = firefox_binary\n            options.binary = firefox_binary\n        if firefox_profile is not None:\n            if isinstance(firefox_profile, basestring):\n                firefox_profile = FirefoxProfile(firefox_profile)\n            self.profile = firefox_profile\n            options.profile = firefox_profile\n    \n        # W3C remote\n        # TODO(ato): Perform conformance negotiation\n    \n        if capabilities.get(\"marionette\"):\n            capabilities.pop(\"marionette\")\n            self.service = Service(\n                executable_path,\n                service_args=service_args,\n                log_path=service_log_path)\n>           self.service.start()\n\n..\\dnbassignment\\venv\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:164: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.firefox.service.Service object at 0x000001F1B77EF220>\n\n    def start(self):\n        \"\"\"\n        Starts the Service.\n    \n        :Exceptions:\n         - WebDriverException : Raised either when it can't start the service\n           or when it can't connect to the service\n        \"\"\"\n        try:\n            cmd = [self.path]\n            cmd.extend(self.command_line_args())\n            self.process = subprocess.Popen(cmd, env=self.env,\n                                            close_fds=platform.system() != 'Windows',\n                                            stdout=self.log_file,\n                                            stderr=self.log_file,\n                                            stdin=PIPE)\n        except TypeError:\n            raise\n        except OSError as err:\n            if err.errno == errno.ENOENT:\n>               raise WebDriverException(\n                    \"'%s' executable needs to be in PATH. %s\" % (\n                        os.path.basename(self.path), self.start_error_message)\nE                       selenium.common.exceptions.WebDriverException: Message: 'geckodriver.exe' executable needs to be in PATH.\n\n..\\dnbassignment\\venv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:81: WebDriverException\n\nDuring handling of the above exception, another exception occurred:\n\nself = <Tests.test_InvalidLogin.Test_InvalidLogin object at 0x000001F1B77EF8E0>\n\n    @allure.description(\"Test Run Through Invalid Inputs\")\n    @allure.step\n    def test_RunThroughInvalidInputs(self):\n        driver = None\n        try:\n>           driver = WebdriverFactory().get_driver(CommonData.BROWSER)\n\nTests\\test_InvalidLogin.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Utils.WebdriverFactory.WebdriverFactory object at 0x000001F1B77EF910>, browser = 'firefox'\n\n    def get_driver(self, browser):\n        try:\n            print(browser)\n            if browser.lower() == \"firefox\":\n                #driver = webdriver.Firefox(executable_path=\"C:\\\\Users\\\\Dpkpc\\\\PycharmProjects\\\\DNBAssignment Pytest\\\\Driver\\\\geckodriver.exe\"))\n                driver = webdriver.Firefox(\n                    executable_path=os.path.realpath(__file__)+\"\\\\Driver\\\\geckodriver.exe\")\n            elif browser.lower() == \"chrome\":\n                print(\"We are here\")\n                driver = webdriver.Chrome(executable_path=\"../Driver/chromedriver.exe\")\n            else:\n                raise Exception(\"Invalid Browser value provided\")\n            print(driver)\n            return driver\n        except:\n>           raise Exception(str(sys.exc_info()))\nE           Exception: (<class 'selenium.common.exceptions.WebDriverException'>, WebDriverException(\"'geckodriver.exe' executable needs to be in PATH. \"), <traceback object at 0x000001F1B780F440>)\n\nUtils\\WebdriverFactory.py:27: Exception\n\nDuring handling of the above exception, another exception occurred:\n\nself = <Tests.test_InvalidLogin.Test_InvalidLogin object at 0x000001F1B77EF8E0>\n\n    @allure.description(\"Test Run Through Invalid Inputs\")\n    @allure.step\n    def test_RunThroughInvalidInputs(self):\n        driver = None\n        try:\n            driver = WebdriverFactory().get_driver(CommonData.BROWSER)\n            driver.get(CommonData.BASEURL)\n            lp = LoginPage(driver)\n            lp.excel_iteration()\n        except:\n            if driver:\n                allure.attach(driver.get_screenshot_as_png(),\n                              name=\"Screenshot of Error\",\n                              attachment_type=allure.attachment_type.PNG)\n                allure.attach(str(sys.exc_info()), 'Error Trace', allure.attachment_type.TEXT)\n>           raise Exception(str(sys.exc_info()))\nE           Exception: (<class 'Exception'>, Exception('(<class \\'selenium.common.exceptions.WebDriverException\\'>, WebDriverException(\"\\'geckodriver.exe\\' executable needs to be in PATH. \"), <traceback object at 0x000001F1B780F440>)'), <traceback object at 0x000001F1B780F900>)\n\nTests\\test_InvalidLogin.py:37: Exception"}, "description": "Test Run Through Invalid Inputs", "steps": [{"name": "test_RunThroughInvalidInputs", "status": "broken", "statusDetails": {"message": "Exception: (<class 'Exception'>, Exception('(<class \\'selenium.common.exceptions.WebDriverException\\'>, WebDriverException(\"\\'geckodriver.exe\\' executable needs to be in PATH. \"), <traceback object at 0x000001F1B780F440>)'), <traceback object at 0x000001F1B780F900>)\n", "trace": "  File \"c:\\users\\dpkpc\\pycharmprojects\\dnbassignment\\venv\\lib\\site-packages\\allure_commons\\_allure.py\", line 172, in impl\n    return func(*a, **kw)\n  File \"C:\\Users\\Dpkpc\\PycharmProjects\\DNBAssignment Pytest\\Tests\\test_InvalidLogin.py\", line 37, in test_RunThroughInvalidInputs\n    raise Exception(str(sys.exc_info()))\n"}, "start": 1622979592777, "stop": 1622979592789}], "attachments": [{"name": "stdout", "source": "292fcecc-2c01-4637-a57d-a234b9bc2495-attachment.txt", "type": "text/plain"}], "start": 1622979592777, "stop": 1622979592791, "uuid": "ab52caf6-d53e-4d05-a270-0aa411c4e577", "historyId": "009d1011368ce3f9da70162cce4254b7", "testCaseId": "2bef674a9cac19ff605e3e0006274f6e", "fullName": "Tests.test_InvalidLogin.Test_InvalidLogin#test_RunThroughInvalidInputs", "labels": [{"name": "parentSuite", "value": "Tests"}, {"name": "suite", "value": "test_InvalidLogin"}, {"name": "subSuite", "value": "Test_InvalidLogin"}, {"name": "host", "value": "DESKTOP-3H0QEFI"}, {"name": "thread", "value": "7588-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "Tests.test_InvalidLogin"}]}